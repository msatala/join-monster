{"version":3,"sources":["../../src/batch-planner/index.js"],"names":["nextBatch","sqlAST","data","dbCall","context","options","paginate","Array","isArray","flatMap","map","value","edges","length","children","Object","values","typedChildren","forEach","push","Promise","all","childAST","nextBatchChild","type","fieldName","sqlBatch","junction","thisKey","parentKey","batchScope","obj","sql","shapeDefinition","newData","group","key","grabMany","total","matchedData","ob","nextLevelData","filter","targets"],"mappings":"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","sourcesContent":["import { uniq, chain, map, groupBy, forIn } from 'lodash'\nimport arrToConnection from '../array-to-connection'\nimport { handleUserDbCall, maybeQuote, wrap, compileSqlAST } from '../util'\nimport idx from 'idx'\n\nasync function nextBatch(sqlAST, data, dbCall, context, options) {\n  // paginated fields are wrapped in connections. strip those off for the batching\n  if (sqlAST.paginate) {\n    if (Array.isArray(data)) {\n      data = chain(data)\n        .flatMap('edges')\n        .map('node')\n        .value()\n    } else {\n      data = map(data.edges, 'node')\n    }\n  }\n  if (!data || (Array.isArray(data) && data.length === 0)) {\n    return\n  }\n\n  const children = sqlAST.children\n  Object.values(sqlAST.typedChildren || {}).forEach(typedChildren =>\n    children.push(...typedChildren)\n  )\n\n  // loop through all the child fields that are tables\n  return Promise.all(\n    children.map(childAST =>\n      nextBatchChild(childAST, data, dbCall, context, options)\n    )\n  )\n}\n\n// processes a single child of the batch\nasync function nextBatchChild(childAST, data, dbCall, context, options) {\n  if (childAST.type !== 'table' && childAST.type !== 'union') return\n\n  const fieldName = childAST.fieldName\n\n  // see if any begin a new batch\n  if (childAST.sqlBatch || idx(childAST, _ => _.junction.sqlBatch)) {\n    let thisKey\n    let parentKey\n    if (childAST.sqlBatch) {\n      // if so, we know we'll need to get the key for matching with the parent key\n      childAST.children.push(childAST.sqlBatch.thisKey)\n      thisKey = childAST.sqlBatch.thisKey.fieldName\n      parentKey = childAST.sqlBatch.parentKey.fieldName\n    } else if (idx(childAST, _ => _.junction.sqlBatch)) {\n      childAST.children.push(childAST.junction.sqlBatch.thisKey)\n      thisKey = childAST.junction.sqlBatch.thisKey.fieldName\n      parentKey = childAST.junction.sqlBatch.parentKey.fieldName\n    }\n\n    if (Array.isArray(data)) {\n      // the \"batch scope\" is teh set of values to match this key against from the previous batch\n      const batchScope = uniq(data.map(obj => maybeQuote(obj[parentKey])))\n      // generate the SQL, with the batch scope values incorporated in a WHERE IN clause\n      const { sql, shapeDefinition } = await compileSqlAST(childAST, context, {\n        ...options,\n        batchScope\n      })\n      // grab the data\n      let newData = await handleUserDbCall(\n        dbCall,\n        sql,\n        childAST,\n        wrap(shapeDefinition)\n      )\n      // group the rows by the key so we can match them with the previous batch\n      newData = groupBy(newData, thisKey)\n      // but if we paginate, we must convert to connection type first\n      if (childAST.paginate) {\n        forIn(newData, (group, key, obj) => {\n          obj[key] = arrToConnection(group, childAST)\n        })\n      }\n      // if we they want many rows, give them an array\n      if (childAST.grabMany) {\n        for (let obj of data) {\n          obj[fieldName] =\n            newData[obj[parentKey]] ||\n            (childAST.paginate ? { total: 0, edges: [] } : [])\n        }\n      } else {\n        let matchedData = []\n        for (let obj of data) {\n          const ob = newData[obj[parentKey]]\n          if (ob) {\n            obj[fieldName] = arrToConnection(\n              newData[obj[parentKey]][0],\n              childAST\n            )\n            matchedData.push(obj)\n          } else {\n            obj[fieldName] = null\n          }\n        }\n        data = matchedData\n      }\n\n      // move down a level and recurse\n      const nextLevelData = chain(data)\n        .filter(obj => obj != null)\n        .flatMap(obj => obj[fieldName])\n        .filter(obj => obj != null)\n        .value()\n      return nextBatch(childAST, nextLevelData, dbCall, context, options)\n    }\n    const batchScope = [maybeQuote(data[parentKey])]\n    const { sql, shapeDefinition } = await compileSqlAST(childAST, context, {\n      ...options,\n      batchScope\n    })\n    let newData = await handleUserDbCall(\n      dbCall,\n      sql,\n      childAST,\n      wrap(shapeDefinition)\n    )\n    newData = groupBy(newData, thisKey)\n    if (childAST.paginate) {\n      const targets = newData[data[parentKey]]\n      data[fieldName] = arrToConnection(targets, childAST)\n    } else if (childAST.grabMany) {\n      data[fieldName] = newData[data[parentKey]] || []\n    } else {\n      const targets = newData[data[parentKey]] || []\n      data[fieldName] = targets[0]\n    }\n    if (data) {\n      return nextBatch(childAST, data[fieldName], dbCall, context, options)\n    }\n\n    // otherwise, just bypass this and recurse down to the next level\n  } else if (Array.isArray(data)) {\n    const nextLevelData = chain(data)\n      .filter(obj => obj != null)\n      .flatMap(obj => obj[fieldName])\n      .filter(obj => obj != null)\n      .value()\n    return nextBatch(childAST, nextLevelData, dbCall, context, options)\n  } else if (data) {\n    return nextBatch(childAST, data[fieldName], dbCall, context, options)\n  }\n}\n\nexport default nextBatch\n"],"file":"index.js"}