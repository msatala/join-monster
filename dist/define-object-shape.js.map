{"version":3,"sources":["../src/define-object-shape.js"],"names":["defineObjectShape","topNode","_defineObjectShape","parent","prefix","node","prefixToPass","as","fieldDefinition","child","children","type","fieldName","name","names","sqlBatch","parentKey","definition","Error","typeName","typedChildren","suffix","junction","grabMany"],"mappings":";;;;;;;AAAA;;AAGA;AACA;AACe,SAASA,iBAAT,CAA2BC,OAA3B,EAAoC;AACjD,4BAAeA,OAAf;AACA,SAAOC,kBAAkB,CAAC,IAAD,EAAO,EAAP,EAAWD,OAAX,CAAzB;AACD;;AAED,SAASC,kBAAT,CAA4BC,MAA5B,EAAoCC,MAApC,EAA4CC,IAA5C,EAAkD;AAAA;;AAChD;AACA,QAAMC,YAAY,GAAGH,MAAM,GAAGC,MAAM,GAAGC,IAAI,CAACE,EAAd,GAAmB,IAAtB,GAA6BH,MAAxD;AAEA,QAAMI,eAAe,GAAG,EAAxB;;AAEA,OAAK,IAAIC,KAAT,IAAkBJ,IAAI,CAACK,QAAvB,EAAiC;AAC/B,YAAQD,KAAK,CAACE,IAAd;AACE,WAAK,QAAL;AACEH,QAAAA,eAAe,CAACC,KAAK,CAACG,SAAP,CAAf,GAAmCN,YAAY,GAAGG,KAAK,CAACF,EAAxD;AACA;;AACF,WAAK,WAAL;AACEC,QAAAA,eAAe,CAACC,KAAK,CAACG,SAAP,CAAf,GAAmCN,YAAY,GAAGG,KAAK,CAACF,EAAxD;AACA;;AACF,WAAK,YAAL;AACE,aAAK,IAAIM,IAAT,IAAiBJ,KAAK,CAACK,KAAvB,EAA8B;AAC5BN,UAAAA,eAAe,CAACK,IAAD,CAAf,GAAwBP,YAAY,GAAGG,KAAK,CAACK,KAAN,CAAYD,IAAZ,CAAvC;AACD;;AACD;;AACF,WAAK,YAAL;AACEL,QAAAA,eAAe,CAACC,KAAK,CAACG,SAAP,CAAf,GAAmCN,YAAY,GAAGG,KAAK,CAACF,EAAxD;AACA;;AACF,WAAK,OAAL;AACA,WAAK,OAAL;AACE,YAAIE,KAAK,CAACM,QAAV,EAAoB;AAClBP,UAAAA,eAAe,CAACC,KAAK,CAACM,QAAN,CAAeC,SAAf,CAAyBJ,SAA1B,CAAf,GACEN,YAAY,GAAGG,KAAK,CAACM,QAAN,CAAeC,SAAf,CAAyBT,EAD1C;AAED,SAHD,MAGO;AACL,gBAAMU,UAAU,GAAGf,kBAAkB,CAACG,IAAD,EAAOC,YAAP,EAAqBG,KAArB,CAArC;;AACAD,UAAAA,eAAe,CAACC,KAAK,CAACG,SAAP,CAAf,GAAmCK,UAAnC;AACD;;AACD;;AACF,WAAK,MAAL;AACE,aAAK,CAAL;AACA;;AACF;;AACA;AACE,cAAM,IAAIC,KAAJ,CAAW,4BAA2B,mBAAQT,KAAK,CAACE,IAAd,CAAoB,EAA1D,CAAN;AA9BJ;AAgCD;;AAED,OAAK,IAAIQ,QAAT,IAAqBd,IAAI,CAACe,aAAL,IAAsB,EAA3C,EAA+C;AAC7C,UAAMC,MAAM,GAAG,MAAMF,QAArB;;AACA,SAAK,IAAIV,KAAT,IAAkBJ,IAAI,CAACe,aAAL,CAAmBD,QAAnB,CAAlB,EAAgD;AAC9C,cAAQV,KAAK,CAACE,IAAd;AACE,aAAK,QAAL;AACEH,UAAAA,eAAe,CAACC,KAAK,CAACG,SAAN,GAAkBS,MAAnB,CAAf,GAA4Cf,YAAY,GAAGG,KAAK,CAACF,EAAjE;AACA;;AACF,aAAK,WAAL;AACEC,UAAAA,eAAe,CAACC,KAAK,CAACG,SAAN,GAAkBS,MAAnB,CAAf,GAA4Cf,YAAY,GAAGG,KAAK,CAACF,EAAjE;AACA;;AACF,aAAK,YAAL;AACE,eAAK,IAAIM,IAAT,IAAiBJ,KAAK,CAACK,KAAvB,EAA8B;AAC5BN,YAAAA,eAAe,CAACK,IAAI,GAAGQ,MAAR,CAAf,GAAiCf,YAAY,GAAGG,KAAK,CAACK,KAAN,CAAYD,IAAZ,CAAhD;AACD;;AACD;;AACF,aAAK,YAAL;AACEL,UAAAA,eAAe,CAACC,KAAK,CAACG,SAAN,GAAkBS,MAAnB,CAAf,GAA4Cf,YAAY,GAAGG,KAAK,CAACF,EAAjE;AACA;;AACF,aAAK,OAAL;AACA,aAAK,OAAL;AACE,cAAIE,KAAK,CAACM,QAAV,EAAoB;AAClBP,YAAAA,eAAe,CAACC,KAAK,CAACM,QAAN,CAAeC,SAAf,CAAyBJ,SAAzB,GAAqCS,MAAtC,CAAf,GACEf,YAAY,GAAGG,KAAK,CAACM,QAAN,CAAeC,SAAf,CAAyBT,EAD1C;AAED,WAHD,MAGO,YAAQE,KAAR,yBAAsBa,QAAtB,iBAA+BP,QAA/B,gBAA0C;AAC/CP,YAAAA,eAAe,CACbC,KAAK,CAACa,QAAN,CAAeP,QAAf,CAAwBC,SAAxB,CAAkCJ,SAAlC,GAA8CS,MADjC,CAAf,GAEIf,YAAY,GAAGG,KAAK,CAACa,QAAN,CAAeP,QAAf,CAAwBC,SAAxB,CAAkCT,EAFrD;AAGD,WAJM,MAIA;AACL,kBAAMU,UAAU,GAAGf,kBAAkB,CAACG,IAAD,EAAOC,YAAP,EAAqBG,KAArB,CAArC;;AACAD,YAAAA,eAAe,CAACC,KAAK,CAACG,SAAN,GAAkBS,MAAnB,CAAf,GAA4CJ,UAA5C;AACD;;AACD;;AACF,aAAK,MAAL;AACE,eAAK,CAAL;AACA;;AACF;;AACA;AACE,gBAAM,IAAIC,KAAJ,CAAW,4BAA2B,mBAAQT,KAAK,CAACE,IAAd,CAAoB,EAA1D,CAAN;AAlCJ;AAoCD;AACF,GAjF+C,CAmFhD;;;AACA,MAAIN,IAAI,CAACkB,QAAT,EAAmB;AACjB,WAAO,CAACf,eAAD,CAAP,CADiB,CAEjB;AACD;;AACD,SAAOA,eAAP;AACD","sourcesContent":["import { validateSqlAST, inspect } from './util'\nimport idx from 'idx'\n\n// generate an object that defines the correct nesting shape for our GraphQL\n// this will be used by the library NestHydrationJS, check out their docs\nexport default function defineObjectShape(topNode) {\n  validateSqlAST(topNode)\n  return _defineObjectShape(null, '', topNode)\n}\n\nfunction _defineObjectShape(parent, prefix, node) {\n  // if this table has a parent, prefix with the parent name and 2 underscores\n  const prefixToPass = parent ? prefix + node.as + '__' : prefix\n\n  const fieldDefinition = {}\n\n  for (let child of node.children) {\n    switch (child.type) {\n      case 'column':\n        fieldDefinition[child.fieldName] = prefixToPass + child.as\n        break\n      case 'composite':\n        fieldDefinition[child.fieldName] = prefixToPass + child.as\n        break\n      case 'columnDeps':\n        for (let name in child.names) {\n          fieldDefinition[name] = prefixToPass + child.names[name]\n        }\n        break\n      case 'expression':\n        fieldDefinition[child.fieldName] = prefixToPass + child.as\n        break\n      case 'union':\n      case 'table':\n        if (child.sqlBatch) {\n          fieldDefinition[child.sqlBatch.parentKey.fieldName] =\n            prefixToPass + child.sqlBatch.parentKey.as\n        } else {\n          const definition = _defineObjectShape(node, prefixToPass, child)\n          fieldDefinition[child.fieldName] = definition\n        }\n        break\n      case 'noop':\n        void 0\n        break\n      /* istanbul ignore next */\n      default:\n        throw new Error(`invalid SQLASTNode type: ${inspect(child.type)}`)\n    }\n  }\n\n  for (let typeName in node.typedChildren || {}) {\n    const suffix = '@' + typeName\n    for (let child of node.typedChildren[typeName]) {\n      switch (child.type) {\n        case 'column':\n          fieldDefinition[child.fieldName + suffix] = prefixToPass + child.as\n          break\n        case 'composite':\n          fieldDefinition[child.fieldName + suffix] = prefixToPass + child.as\n          break\n        case 'columnDeps':\n          for (let name in child.names) {\n            fieldDefinition[name + suffix] = prefixToPass + child.names[name]\n          }\n          break\n        case 'expression':\n          fieldDefinition[child.fieldName + suffix] = prefixToPass + child.as\n          break\n        case 'union':\n        case 'table':\n          if (child.sqlBatch) {\n            fieldDefinition[child.sqlBatch.parentKey.fieldName + suffix] =\n              prefixToPass + child.sqlBatch.parentKey.as\n          } else if (idx(child, _ => _.junction.sqlBatch)) {\n            fieldDefinition[\n              child.junction.sqlBatch.parentKey.fieldName + suffix\n            ] = prefixToPass + child.junction.sqlBatch.parentKey.as\n          } else {\n            const definition = _defineObjectShape(node, prefixToPass, child)\n            fieldDefinition[child.fieldName + suffix] = definition\n          }\n          break\n        case 'noop':\n          void 0\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`invalid SQLASTNode type: ${inspect(child.type)}`)\n      }\n    }\n  }\n\n  // if we need many, just wrap the field definition in an array\n  if (node.grabMany) {\n    return [fieldDefinition]\n    // otherwise, it will just grab the first result\n  }\n  return fieldDefinition\n}\n"],"file":"define-object-shape.js"}