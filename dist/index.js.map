{"version":3,"sources":["../src/index.js"],"names":["joinMonster","resolveInfo","context","dbCall","options","sqlAST","queryAST","queryASTToSqlAST","sql","shapeDefinition","data","Array","isArray","childrenToCheck","children","filter","child","sqlBatch","d","fieldName","getNode","typeName","condition","type","schema","_typeMap","_typeConfig","sqlTable","where","fakeParentNode","_fields","node","name","toLowerCase","namespace","AliasNamespace","minify","fieldNodes","fieldASTs","populateASTNode","call","pruneDuplicateSqlDeps","__type__","version","require"],"mappings":"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","sourcesContent":["import assert from 'assert'\n\nimport * as queryAST from './query-ast-to-sql-ast'\nimport arrToConnection from './array-to-connection'\nimport AliasNamespace from './alias-namespace'\nimport nextBatch from './batch-planner'\nimport { buildWhereFunction, handleUserDbCall, compileSqlAST } from './util'\n\n/*         _ _ _                _\n  ___ __ _| | | |__   __ _  ___| | __\n / __/ _` | | | '_ \\ / _` |/ __| |/ /\n| (_| (_| | | | |_) | (_| | (__|   <\n \\___\\__,_|_|_|_.__/ \\__,_|\\___|_|\\_\\\n\n     _       __ _       _ _   _\n  __| | ___ / _(_)_ __ (_) |_(_) ___  _ __  ___\n / _` |/ _ \\ |_| | '_ \\| | __| |/ _ \\| '_ \\/ __|\n| (_| |  __/  _| | | | | | |_| | (_) | | | \\__ \\\n \\__,_|\\___|_| |_|_| |_|_|\\__|_|\\___/|_| |_|___/\n*/\n\n/**\n * User-defined function that sends a raw SQL query to the databse.\n * @callback dbCall\n * @param {String} sql - The SQL generated by `joinMonster` for the batch fetching. Use it to get the data from your database.\n * @param {Function} [done] - An error-first \"done\" callback. Only define this parameter if you don't want to return a `Promise`.\n * @returns {Promise.<Array>} The raw data as a flat array of objects. Each object must represent a row from the result set.\n */\n/**\n * Function for generating a SQL expression.\n * @callback sqlExpr\n * @param {String} tableAlias - The alias generated for this table. Already double-quoted.\n * @param {Object} args - The GraphQL arguments for this field.\n * @param {Object} context - An Object with arbitrary contextual information.\n * @param {Object} sqlASTNode - Join Monster object that abstractly represents this field. Also includes a reference to its parent node. This is useful, for example, if you need to access the parent field's table alias or GraphQL arguments.\n * @returns {String|Promise.<String>} The RAW expression interpolated into the query to compute the column. Unsafe user input must be scrubbed.\n */\n/**\n * Function for generating a `WHERE` condition.\n * @callback where\n * @param {String} tableAlias - The alias generated for this table. Already double-quoted.\n * @param {Object} args - The GraphQL arguments for this field.\n * @param {Object} context - An Object with arbitrary contextual information.\n * @param {Object} sqlASTNode - Join Monster object that abstractly represents this field. Also includes a reference to its parent node. This is useful, for example, if you need to access the parent field's table alias or GraphQL arguments.\n * @returns {String|Promise.<String>} The RAW condition for the `WHERE` clause. Omitted if falsy value returned. Unsafe user input must be scrubbed.\n */\n/**\n * Function for generating a `JOIN` condition.\n * @callback sqlJoin\n * @param {String} parentTable - The alias generated for the parent's table. Already double-quoted.\n * @param {String} childTable - The alias for the child's table. Already double-quoted.\n * @param {Object} args - The GraphQL arguments for this field.\n * @param {Object} context - An Object with arbitrary contextual information.\n * @param {Object} sqlASTNode - Join Monster object that abstractly represents this field. Also includes a reference to its parent node. This is useful, for example, if you need to access the parent field's table alias or GraphQL arguments.\n * @returns {String} The RAW condition for the `LEFT JOIN`. Unsafe user input must be scrubbed.\n */\n/**\n * Rather than a constant value, its a function to dynamically return the value.\n * @callback thunk\n * @param {Object} args - The GraphQL arguments for this field.\n * @param {Object} context - An Object with arbitrary contextual information.\n */\n\n/* _                _\n  | |__   ___  __ _(_)_ __    ___  ___  _   _ _ __ ___ ___\n  | '_ \\ / _ \\/ _` | | '_ \\  / __|/ _ \\| | | | '__/ __/ _ \\\n  | |_) |  __/ (_| | | | | | \\__ \\ (_) | |_| | | | (_|  __/\n  |_.__/ \\___|\\__, |_|_| |_| |___/\\___/ \\__,_|_|  \\___\\___|\n              |___/\n*/\n\n/**\n * Takes the GraphQL resolveInfo and returns a hydrated Object with the data.\n * @param {Object} resolveInfo - Contains the parsed GraphQL query, schema definition, and more. Obtained from the fourth argument to the resolver.\n * @param {Object} context - An arbitrary object that gets passed to the `where` function. Useful for contextual infomation that influeces the  `WHERE` condition, e.g. session, logged in user, localization.\n * @param {dbCall} dbCall - A function that is passed the compiled SQL that calls the database and returns a promise of the data.\n * @param {Object} [options]\n * @param {Boolean} options.minify - Generate minimum-length column names in the results table.\n * @param {String} options.dialect - The dialect of SQL your Database uses. Currently `'pg'`, `'oracle'`, `'mariadb'`, `'mysql'`, and `'sqlite3'` are supported.\n * @param {Object} options.dialectModule - An alternative to options.dialect. You can provide a custom implementation of one of the supported dialects.\n * @returns {Promise.<Object>} The correctly nested data from the database.\n */\nasync function joinMonster(resolveInfo, context, dbCall, options = {}) {\n  // we need to read the query AST and build a new \"SQL AST\" from which the SQL and\n  const sqlAST = queryAST.queryASTToSqlAST(resolveInfo, options, context)\n  const { sql, shapeDefinition } = await compileSqlAST(sqlAST, context, options)\n  if (!sql) return {}\n\n  // call their function for querying the DB, handle the different cases, do some validation, return a promise of the object\n  let data = await handleUserDbCall(dbCall, sql, sqlAST, shapeDefinition)\n\n  // if they are paginating, we'll get back an array which is essentially a \"slice\" of the whole data.\n  // this function goes through the data tree and converts the arrays to Connection Objects\n  data = arrToConnection(data, sqlAST)\n\n  // so far we handled the first \"batch\". up until now, additional batches were ignored\n  // this function recursively scanss the sqlAST and runs remaining batches\n  await nextBatch(sqlAST, data, dbCall, context, options)\n\n  // check for batch data\n  if (Array.isArray(data)) {\n    const childrenToCheck = sqlAST.children.filter(child => child.sqlBatch)\n    return data.filter(d => {\n      for (const child of childrenToCheck) {\n        if (d[child.fieldName] == null) {\n          return false\n        }\n      }\n      return true\n    })\n  }\n\n  return data\n}\n\n/**\n * A helper for resolving the Node type in Relay.\n * @param {String} typeName - The Name of the GraphQLObjectType\n * @param {Object} resolveInfo - Contains the parsed GraphQL query, schema definition, and more. Obtained from the fourth argument to the resolver.\n * @param {Object} context - An arbitrary object that gets passed to the `where` function. Useful for contextual infomation that influeces the  WHERE condition, e.g. session, logged in user, localization.\n * @param {where|Number|String|Array} condition - A value to determine the `where` function for searching the node. If it's a function, that function will be used as the `where` function. Otherwise, it is assumed to be the value(s) of the `primaryKey`. An array of values is needed for composite primary keys.\n * @param {Function} dbCall - A function that is passed the compiled SQL that calls the database and returns (a promise of) the data.\n * @param {Object} [options] - Same as `joinMonster` function's options.\n * @returns {Promise.<Object>} The correctly nested data from the database. The GraphQL Type is added to the \"\\_\\_type\\_\\_\" property, which is helpful for the `resolveType` function in the `nodeDefinitions` of **graphql-relay-js**.\n */\nasync function getNode(\n  typeName,\n  resolveInfo,\n  context,\n  condition,\n  dbCall,\n  options = {}\n) {\n  // get the GraphQL type from the schema using the name\n  const type = resolveInfo.schema._typeMap[typeName]\n  assert(type, `Type \"${typeName}\" not found in your schema.`)\n  assert(\n    type._typeConfig.sqlTable,\n    `joinMonster can't fetch a ${typeName} as a Node unless it has \"sqlTable\" tagged.`\n  )\n\n  // we need to determine what the WHERE function should be\n  let where = buildWhereFunction(type, condition, options)\n\n  // our getGraphQLType expects every requested field to be in the schema definition. \"node\" isn't a parent of whatever type we're getting, so we'll just wrap that type in an object that LOOKS that same as a hypothetical Node type\n  const fakeParentNode = {\n    _fields: {\n      node: {\n        type,\n        name: type.name.toLowerCase(),\n        where\n      }\n    }\n  }\n  const namespace = new AliasNamespace(options.minify)\n  const sqlAST = {}\n  const fieldNodes = resolveInfo.fieldNodes || resolveInfo.fieldASTs\n  // uses the same underlying function as the main `joinMonster`\n  queryAST.populateASTNode.call(\n    resolveInfo,\n    fieldNodes[0],\n    fakeParentNode,\n    sqlAST,\n    namespace,\n    0,\n    options,\n    context\n  )\n  queryAST.pruneDuplicateSqlDeps(sqlAST, namespace)\n  const { sql, shapeDefinition } = await compileSqlAST(sqlAST, context, options)\n  const data = arrToConnection(\n    await handleUserDbCall(dbCall, sql, sqlAST, shapeDefinition),\n    sqlAST\n  )\n  await nextBatch(sqlAST, data, dbCall, context, options)\n  if (!data) return data\n  data.__type__ = type\n  return data\n}\n\njoinMonster.getNode = getNode\n\n// expose the package version for debugging\njoinMonster.version = require('../package.json').version\nexport default joinMonster\n"],"file":"index.js"}