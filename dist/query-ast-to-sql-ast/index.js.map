{"version":3,"sources":["../../src/query-ast-to-sql-ast/index.js"],"names":["SQLASTNode","constructor","parentNode","props","Object","defineProperty","enumerable","value","prop","TABLE_TYPES","mergeAll","fieldNodes","newFieldNodes","length","push","merge","pop","dest","src","selectionSet","selections","queryASTToSqlAST","resolveInfo","options","context","namespace","AliasNamespace","dialect","minify","sqlAST","fieldASTs","assert","equal","queryAST","parentType","populateASTNode","call","ok","indexOf","type","pruneDuplicateSqlDeps","queryASTNode","parentTypeNode","sqlASTNode","depth","fieldName","name","test","field","_fields","Error","fieldIncludes","parent","junction","include","fromOtherTable","as","jmIgnoreAll","grabMany","gqlType","stripNonNullType","args","variableValues","ofType","edges","pageInfo","stripped","stripRelayConnection","fragments","sqlPaginate","paginate","config","_typeConfig","jmIgnoreTable","includes","sqlTable","junctionTable","sqlJoin","sqlBatch","handleTable","sqlExpr","aliasFrom","defferedFrom","generate","sqlColumn","resolve","sqlDeps","names","orderBy","handleOrderBy","children","where","sqlJoins","keyToASTChild","thisKey","columnToASTChild","parentKey","limit","getSortColumns","alwaysFetch","column","typeHint","handleColumnsRequiredForPagination","typedChildren","handleUnionSelections","handleSelections","internalOptions","selection","kind","existingNode","find","child","newNode","selectionNameOfType","typeCondition","deferredType","schema","_typeMap","deferToObjectType","handler","fragmentName","fragment","fragmentNameOfType","sameType","interfaceType","_interfaces","map","iface","columnName","toClumsyName","keyArr","slice","join","key","Array","isArray","clumsyName","sortKey","order","newChild","edgeType","strippedType","node","arguments","spreadFragments","childrenToLoopOver","values","depsByTable","i","keyName","forEach","Set","add","splice","table","typeName","undefined","orderColumns","direction","toUpperCase"],"mappings":"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","sourcesContent":["import assert from 'assert'\nimport { flatMap } from 'lodash'\nimport deprecate from 'deprecate'\nimport { getArgumentValues } from 'graphql/execution/values'\nimport idx from 'idx'\n\nimport AliasNamespace from '../alias-namespace'\nimport { wrap, ensure, unthunk, inspect } from '../util'\n\nclass SQLASTNode {\n  constructor(parentNode, props) {\n    Object.defineProperty(this, 'parent', {\n      enumerable: false,\n      value: parentNode\n    })\n\n    for (let prop in props) {\n      this[prop] = props[prop]\n    }\n  }\n}\n\n// an enumeration of all the types that can map to SQL tables\nconst TABLE_TYPES = [\n  'GraphQLObjectType',\n  'GraphQLUnionType',\n  'GraphQLInterfaceType'\n]\n\nfunction mergeAll(fieldNodes) {\n  const newFieldNodes = [...fieldNodes]\n  while (newFieldNodes.length > 1) {\n    newFieldNodes.push(merge(newFieldNodes.pop(), newFieldNodes.pop()))\n  }\n  return newFieldNodes\n}\n\nfunction merge(dest, src) {\n  return {\n    ...dest,\n    selectionSet: {\n      ...dest.selectionSet,\n      selections: [\n        ...dest.selectionSet.selections,\n        ...src.selectionSet.selections\n      ]\n    }\n  }\n}\n\nexport function queryASTToSqlAST(resolveInfo, options, context) {\n  // this is responsible for all the logic regarding creating SQL aliases\n  // we need varying degrees of uniqueness and readability\n  // force oracle to minify, because it has this 30-character limit on column identifiers\n  const namespace = new AliasNamespace(\n    options.dialect === 'oracle' ? true : options.minify\n  )\n\n  // we'll build up the AST representing the SQL recursively\n  const sqlAST = {}\n\n  // v0.8 changed the \"fieldASTs\" property to \"fieldNodes\". we want to support both\n  let fieldNodes = resolveInfo.fieldNodes || resolveInfo.fieldASTs\n\n  // fieldNodes is usually an array of 1 GraphQL node. If a field is requested twice *without* aliases, both nodes will be in this array\n  // we need to merge it into one\n  fieldNodes = mergeAll(fieldNodes)\n  assert.equal(\n    fieldNodes.length,\n    1,\n    'We thought this would always have a length of 1. FIX ME!!'\n  )\n\n  // this represents the parsed query\n  const queryAST = fieldNodes[0]\n  // resolveInfo.parentType is from the schema, its the GraphQLObjectType that is parent to the current field\n  // this allows us to get the field definition of the current field so we can grab that extra metadata\n  // e.g. sqlColumn or sqlJoin, etc.\n  const parentType = resolveInfo.parentType\n  populateASTNode.call(\n    resolveInfo,\n    queryAST,\n    parentType,\n    sqlAST,\n    namespace,\n    0,\n    options,\n    context\n  )\n\n  // make sure they started this party on a table, interface or union.\n  assert.ok(\n    ['table', 'union'].indexOf(sqlAST.type) > -1,\n    'Must call joinMonster in a resolver on a field where the type is decorated with \"sqlTable\".'\n  )\n\n  // make sure each \"sqlDep\" is only specified once at each level. also assign it an alias\n  pruneDuplicateSqlDeps(sqlAST, namespace)\n\n  return sqlAST\n}\n\nexport function populateASTNode(\n  queryASTNode,\n  parentTypeNode,\n  sqlASTNode,\n  namespace,\n  depth,\n  options,\n  context\n) {\n  // first, get the name of the field being queried\n  const fieldName = queryASTNode.name.value\n\n  // if this is an internal field (say, for introspection \"__typename\"), lets ignore it\n  if (/^__/.test(fieldName)) {\n    sqlASTNode.type = 'noop'\n    return\n  }\n\n  // then, get the field from the schema definition\n  let field = parentTypeNode._fields[fieldName]\n  if (!field) {\n    throw new Error(\n      `The field \"${fieldName}\" is not in the ${parentTypeNode.name} type.`\n    )\n  }\n\n  let fieldIncludes\n  if (idx(sqlASTNode, _ => _.parent.junction.include[fieldName])) {\n    fieldIncludes = sqlASTNode.parent.junction.include[fieldName]\n    field = {\n      ...field,\n      ...fieldIncludes\n    }\n    sqlASTNode.fromOtherTable = sqlASTNode.parent.junction.as\n  }\n\n  // allow for explicit ignoring of fields\n  if (field.jmIgnoreAll) {\n    sqlASTNode.type = 'noop'\n    return\n  }\n\n  // this flag will keep track of whether multiple rows are needed\n  let grabMany = false\n  // the actual type might be wrapped in a GraphQLNonNull type\n  let gqlType = stripNonNullType(field.type)\n\n  sqlASTNode.args = getArgumentValues(field, queryASTNode, this.variableValues)\n\n  // if list then mark flag true & get the type inside the GraphQLList container type\n  if (gqlType.constructor.name === 'GraphQLList') {\n    gqlType = stripNonNullType(gqlType.ofType)\n    grabMany = true\n  }\n\n  // if its a relay connection, there are several things we need to do\n  if (\n    gqlType.constructor.name === 'GraphQLObjectType' &&\n    gqlType._fields.edges &&\n    gqlType._fields.pageInfo\n  ) {\n    grabMany = true\n    // grab the types and fields inside the connection\n    const stripped = stripRelayConnection(gqlType, queryASTNode, this.fragments)\n    // reassign those\n    gqlType = stripNonNullType(stripped.gqlType)\n    queryASTNode = stripped.queryASTNode\n    // we'll set a flag for pagination.\n    if (field.sqlPaginate) {\n      sqlASTNode.paginate = true\n    }\n  } else if (field.sqlPaginate) {\n    throw new Error(\n      `To paginate the ${gqlType.name} type, it must be a GraphQLObjectType that fulfills the relay spec.\n      The type must have a \"pageInfo\" and \"edges\" field. https://facebook.github.io/relay/graphql/connections.htm`\n    )\n  }\n  // the typeConfig has all the keyes from the GraphQLObjectType definition\n  const config = gqlType._typeConfig\n\n  // is this a table in SQL?\n  if (\n    !field.jmIgnoreTable &&\n    TABLE_TYPES.includes(gqlType.constructor.name) &&\n    config.sqlTable\n  ) {\n    if (depth >= 1) {\n      assert(\n        !field.junctionTable,\n        '\"junctionTable\" has been replaced with a new API.'\n      )\n      assert(\n        field.sqlJoin || field.sqlBatch || field.junction,\n        `If an Object type maps to a SQL table and has a child which is another Object type that also maps to a SQL table,\n        you must define \"sqlJoin\", \"sqlBatch\", or \"junction\" on that field to tell joinMonster how to fetch it.\n        Or you can ignore it with \"jmIgnoreTable\". Check the \"${fieldName}\" field on the \"${parentTypeNode.name}\" type.`\n      )\n    }\n    handleTable.call(\n      this,\n      sqlASTNode,\n      queryASTNode,\n      field,\n      gqlType,\n      namespace,\n      grabMany,\n      depth,\n      options,\n      context\n    )\n    // is this a computed column from a raw expression?\n  } else if (field.sqlExpr) {\n    sqlASTNode.type = 'expression'\n    sqlASTNode.sqlExpr = field.sqlExpr\n    let aliasFrom = (sqlASTNode.fieldName = field.name)\n    if (sqlASTNode.defferedFrom) {\n      aliasFrom += '@' + parentTypeNode.name\n    }\n    sqlASTNode.as = namespace.generate('column', aliasFrom)\n    // is it just a column? if they specified a sqlColumn or they didn't define a resolver, yeah\n  } else if (field.sqlColumn || !field.resolve) {\n    sqlASTNode.type = 'column'\n    sqlASTNode.name = field.sqlColumn || field.name\n    let aliasFrom = (sqlASTNode.fieldName = field.name)\n    if (sqlASTNode.defferedFrom) {\n      aliasFrom += '@' + parentTypeNode.name\n    }\n    sqlASTNode.as = namespace.generate('column', aliasFrom)\n    // or maybe it just depends on some SQL columns\n  } else if (field.sqlDeps) {\n    sqlASTNode.type = 'columnDeps'\n    sqlASTNode.names = field.sqlDeps\n    // maybe this node wants no business with your SQL, because it has its own resolver\n  } else {\n    sqlASTNode.type = 'noop'\n  }\n}\n\nfunction handleTable(\n  sqlASTNode,\n  queryASTNode,\n  field,\n  gqlType,\n  namespace,\n  grabMany,\n  depth,\n  options,\n  context\n) {\n  const config = gqlType._typeConfig\n\n  sqlASTNode.type = 'table'\n  const sqlTable = unthunk(config.sqlTable, sqlASTNode.args || {}, context)\n  sqlASTNode.name = sqlTable\n\n  // the graphQL field name will be the default alias for the table\n  // if thats taken, this function will just add an underscore to the end to make it unique\n  sqlASTNode.as = namespace.generate('table', field.name)\n\n  if (field.orderBy && !sqlASTNode.orderBy) {\n    sqlASTNode.orderBy = handleOrderBy(\n      unthunk(field.orderBy, sqlASTNode.args || {}, context)\n    )\n  }\n\n  // tables have child fields, lets push them to an array\n  const children = (sqlASTNode.children = sqlASTNode.children || [])\n\n  sqlASTNode.fieldName = field.name\n  sqlASTNode.grabMany = grabMany\n\n  if (field.where) {\n    sqlASTNode.where = field.where\n  }\n\n  /*\n   * figure out if they are doing one-to-many/many-to-many or join/batch\n   * and collect the relevant info\n   */\n\n  // are they doing a one-to-many sql join?\n  if (field.sqlJoin) {\n    sqlASTNode.sqlJoin = field.sqlJoin\n    // or a many-to-many?\n  } else if (field.junction) {\n    const junctionTable = unthunk(\n      ensure(field.junction, 'sqlTable'),\n      sqlASTNode.args || {},\n      context\n    )\n    const junction = (sqlASTNode.junction = {\n      sqlTable: junctionTable,\n      as: namespace.generate('table', junctionTable)\n    })\n    if (field.junction.include) {\n      junction.include = unthunk(\n        field.junction.include,\n        sqlASTNode.args || {},\n        context\n      )\n    }\n\n    if (field.junction.orderBy) {\n      junction.orderBy = handleOrderBy(\n        unthunk(field.junction.orderBy, sqlASTNode.args || {}, context)\n      )\n    }\n\n    if (field.junction.where) {\n      junction.where = field.junction.where\n    }\n    // are they joining or batching?\n    if (field.junction.sqlJoins) {\n      junction.sqlJoins = field.junction.sqlJoins\n    } else if (field.junction.sqlBatch) {\n      children.push({\n        ...keyToASTChild(ensure(field.junction, 'uniqueKey'), namespace),\n        fromOtherTable: junction.as\n      })\n      junction.sqlBatch = {\n        sqlJoin: ensure(field.junction.sqlBatch, 'sqlJoin'),\n        thisKey: {\n          ...columnToASTChild(\n            ensure(field.junction.sqlBatch, 'thisKey'),\n            namespace\n          ),\n          fromOtherTable: junction.as\n        },\n        parentKey: columnToASTChild(\n          ensure(field.junction.sqlBatch, 'parentKey'),\n          namespace\n        )\n      }\n    } else {\n      throw new Error('junction requires either a `sqlJoins` or `sqlBatch`')\n    }\n    // or are they doing a one-to-many with batching\n  } else if (field.sqlBatch) {\n    sqlASTNode.sqlBatch = {\n      thisKey: columnToASTChild(ensure(field.sqlBatch, 'thisKey'), namespace),\n      parentKey: columnToASTChild(\n        ensure(field.sqlBatch, 'parentKey'),\n        namespace\n      )\n    }\n  }\n\n  if (field.limit) {\n    assert(field.orderBy, '`orderBy` is required with `limit`')\n    sqlASTNode.limit = unthunk(field.limit, sqlASTNode.args || {}, context)\n  }\n\n  if (sqlASTNode.paginate) {\n    getSortColumns(field, sqlASTNode, context)\n  }\n\n  /*\n   * figure out the necessary children. this includes the columns join monster needs, the ones the user needs,\n   * and finding out how to map those to the field names\n   */\n\n  // the NestHydrationJS library only treats the first column as the unique identifier, therefore we\n  // need whichever column that the schema specifies as the unique one to be the first child\n  children.push(keyToASTChild(ensure(config, 'uniqueKey'), namespace))\n\n  if (config.alwaysFetch) {\n    for (let column of wrap(config.alwaysFetch)) {\n      children.push(\n        columnToASTChild(\n          unthunk(\n            column,\n            sqlASTNode.as,\n            sqlASTNode.args || {},\n            context,\n            sqlASTNode\n          ),\n          namespace\n        )\n      )\n    }\n  }\n\n  // this was created for helping resolve types in union types\n  // its been generalized to `alwaysFetch`, as its a useful feature for more than just unions\n  if (\n    config.typeHint &&\n    ['GraphQLUnionType', 'GraphQLInterfaceType'].includes(\n      gqlType.constructor.name\n    )\n  ) {\n    deprecate('`typeHint` is deprecated. Use `alwaysFetch` instead.')\n    children.push(columnToASTChild(config.typeHint, namespace))\n  }\n\n  // go handle the pagination information\n  if (sqlASTNode.paginate) {\n    handleColumnsRequiredForPagination(sqlASTNode, namespace)\n  }\n\n  if (queryASTNode.selectionSet) {\n    if (\n      gqlType.constructor.name === 'GraphQLUnionType' ||\n      gqlType.constructor.name === 'GraphQLInterfaceType'\n    ) {\n      // union types have special rules for the child fields in join monster\n      sqlASTNode.type = 'union'\n      sqlASTNode.typedChildren = {}\n      handleUnionSelections.call(\n        this,\n        sqlASTNode,\n        children,\n        queryASTNode.selectionSet.selections,\n        gqlType,\n        namespace,\n        depth,\n        options,\n        context\n      )\n    } else {\n      handleSelections.call(\n        this,\n        sqlASTNode,\n        children,\n        queryASTNode.selectionSet.selections,\n        gqlType,\n        namespace,\n        depth,\n        options,\n        context\n      )\n    }\n  }\n}\n\n// we need to collect all fields from all the fragments requested in the union type and ask for them in SQL\nfunction handleUnionSelections(\n  sqlASTNode,\n  children,\n  selections,\n  gqlType,\n  namespace,\n  depth,\n  options,\n  context,\n  internalOptions = {}\n) {\n  for (let selection of selections) {\n    // we need to figure out what kind of selection this is\n    switch (selection.kind) {\n      case 'Field':\n        // has this field been requested once already? GraphQL does not protect against duplicates so we have to check for it\n        const existingNode = children.find(\n          child =>\n            child.fieldName === selection.name.value && child.type === 'table'\n        )\n        let newNode = new SQLASTNode(sqlASTNode)\n        if (existingNode) {\n          newNode = existingNode\n        } else {\n          children.push(newNode)\n        }\n        if (internalOptions.defferedFrom) {\n          newNode.defferedFrom = internalOptions.defferedFrom\n        }\n        populateASTNode.call(\n          this,\n          selection,\n          gqlType,\n          newNode,\n          namespace,\n          depth + 1,\n          options,\n          context\n        )\n        break\n      // if its an inline fragment, it has some fields and we gotta recurse thru all them\n      case 'InlineFragment':\n        {\n          const selectionNameOfType = selection.typeCondition.name.value\n          // normally, we would scan for the extra join-monster data on the current gqlType.\n          // but the gqlType is the Union. The data isn't there, its on each of the types that make up the union\n          // lets find that type and handle the selections based on THAT type instead\n          const deferredType = this.schema._typeMap[selectionNameOfType]\n          const deferToObjectType =\n            deferredType.constructor.name === 'GraphQLObjectType'\n          const handler = deferToObjectType\n            ? handleSelections\n            : handleUnionSelections\n          if (deferToObjectType) {\n            const typedChildren = sqlASTNode.typedChildren\n            children = typedChildren[deferredType.name] =\n              typedChildren[deferredType.name] || []\n            internalOptions.defferedFrom = gqlType\n          }\n          handler.call(\n            this,\n            sqlASTNode,\n            children,\n            selection.selectionSet.selections,\n            deferredType,\n            namespace,\n            depth,\n            options,\n            context,\n            internalOptions\n          )\n        }\n        break\n      // if its a named fragment, we need to grab the fragment definition by its name and recurse over those fields\n      case 'FragmentSpread':\n        {\n          const fragmentName = selection.name.value\n          const fragment = this.fragments[fragmentName]\n          const fragmentNameOfType = fragment.typeCondition.name.value\n          const deferredType = this.schema._typeMap[fragmentNameOfType]\n          const deferToObjectType =\n            deferredType.constructor.name === 'GraphQLObjectType'\n          const handler = deferToObjectType\n            ? handleSelections\n            : handleUnionSelections\n          if (deferToObjectType) {\n            const typedChildren = sqlASTNode.typedChildren\n            children = typedChildren[deferredType.name] =\n              typedChildren[deferredType.name] || []\n            internalOptions.defferedFrom = gqlType\n          }\n          handler.call(\n            this,\n            sqlASTNode,\n            children,\n            fragment.selectionSet.selections,\n            deferredType,\n            namespace,\n            depth,\n            options,\n            context,\n            internalOptions\n          )\n        }\n        break\n      /* istanbul ignore next */\n      default:\n        throw new Error('Unknown selection kind: ' + selection.kind)\n    }\n  }\n}\n\n// the selections could be several types, recursively handle each type here\nfunction handleSelections(\n  sqlASTNode,\n  children,\n  selections,\n  gqlType,\n  namespace,\n  depth,\n  options,\n  context,\n  internalOptions = {}\n) {\n  for (let selection of selections) {\n    // we need to figure out what kind of selection this is\n    switch (selection.kind) {\n      // if its another field, recurse through that\n      case 'Field':\n        // has this field been requested once already? GraphQL does not protect against duplicates so we have to check for it\n        const existingNode = children.find(\n          child =>\n            child.fieldName === selection.name.value && child.type === 'table'\n        )\n        let newNode = new SQLASTNode(sqlASTNode)\n        if (existingNode) {\n          newNode = existingNode\n        } else {\n          children.push(newNode)\n        }\n        if (internalOptions.defferedFrom) {\n          newNode.defferedFrom = internalOptions.defferedFrom\n        }\n        populateASTNode.call(\n          this,\n          selection,\n          gqlType,\n          newNode,\n          namespace,\n          depth + 1,\n          options,\n          context\n        )\n        break\n      // if its an inline fragment, it has some fields and we gotta recurse thru all them\n      case 'InlineFragment':\n        {\n          // check to make sure the type of this fragment (or one of the interfaces it implements) matches the type being queried\n          const selectionNameOfType = selection.typeCondition.name.value\n          const sameType = selectionNameOfType === gqlType.name\n          const interfaceType = (gqlType._interfaces || [])\n            .map(iface => iface.name)\n            .includes(selectionNameOfType)\n          if (sameType || interfaceType) {\n            handleSelections.call(\n              this,\n              sqlASTNode,\n              children,\n              selection.selectionSet.selections,\n              gqlType,\n              namespace,\n              depth,\n              options,\n              context,\n              internalOptions\n            )\n          }\n        }\n        break\n      // if its a named fragment, we need to grab the fragment definition by its name and recurse over those fields\n      case 'FragmentSpread':\n        {\n          const fragmentName = selection.name.value\n          const fragment = this.fragments[fragmentName]\n          // make sure fragment type (or one of the interfaces it implements) matches the type being queried\n          const fragmentNameOfType = fragment.typeCondition.name.value\n          const sameType = fragmentNameOfType === gqlType.name\n          const interfaceType =\n            gqlType._interfaces\n              .map(iface => iface.name)\n              .indexOf(fragmentNameOfType) >= 0\n          if (sameType || interfaceType) {\n            handleSelections.call(\n              this,\n              sqlASTNode,\n              children,\n              fragment.selectionSet.selections,\n              gqlType,\n              namespace,\n              depth,\n              options,\n              context,\n              internalOptions\n            )\n          }\n        }\n        break\n      /* istanbul ignore next */\n      default:\n        throw new Error('Unknown selection kind: ' + selection.kind)\n    }\n  }\n}\n\n// tell the AST we need a column that perhaps the user didnt ask for, but may be necessary for join monster to ID\n// objects or associate ones across batches\nfunction columnToASTChild(columnName, namespace) {\n  return {\n    type: 'column',\n    name: columnName,\n    fieldName: columnName,\n    as: namespace.generate('column', columnName)\n  }\n}\n\n// generate a name for a composite key based on the individual column names smashed together\n// slice them to help prevent exceeding oracle's 30-char identifier limit\nfunction toClumsyName(keyArr) {\n  return keyArr.map(name => name.slice(0, 3)).join('#')\n}\n\n// keys are necessary for deduplication during the hydration process\n// this will handle singular or composite keys\nfunction keyToASTChild(key, namespace) {\n  if (typeof key === 'string') {\n    return columnToASTChild(key, namespace)\n  }\n  if (Array.isArray(key)) {\n    const clumsyName = toClumsyName(key)\n    return {\n      type: 'composite',\n      name: key,\n      fieldName: clumsyName,\n      as: namespace.generate('column', clumsyName)\n    }\n  }\n}\n\nfunction handleColumnsRequiredForPagination(sqlASTNode, namespace) {\n  if (sqlASTNode.sortKey || idx(sqlASTNode, _ => _.junction.sortKey)) {\n    const sortKey = sqlASTNode.sortKey || sqlASTNode.junction.sortKey\n    assert(sortKey.order, '\"sortKey\" must have \"order\"')\n    // this type of paging uses the \"sort key(s)\". we need to get this in order to generate the cursor\n    for (let column of wrap(ensure(sortKey, 'key'))) {\n      const newChild = columnToASTChild(column, namespace)\n      // if this joining on a \"through-table\", the sort key is on the threw table instead of this node's parent table\n      if (!sqlASTNode.sortKey) {\n        newChild.fromOtherTable = sqlASTNode.junction.as\n      }\n      sqlASTNode.children.push(newChild)\n    }\n  } else if (sqlASTNode.orderBy || idx(sqlASTNode, _ => _.junction.orderBy)) {\n    // this type of paging can visit arbitrary pages, so lets provide the total number of items\n    // on this special \"$total\" column which we will compute in the query\n    const newChild = columnToASTChild('$total', namespace)\n    if (sqlASTNode.junction) {\n      newChild.fromOtherTable = sqlASTNode.junction.as\n    }\n    sqlASTNode.children.push(newChild)\n  }\n}\n\n// if its a connection type, we need to look up the Node type inside their to find the relevant SQL info\nfunction stripRelayConnection(gqlType, queryASTNode, fragments) {\n  // get the GraphQL Type inside the list of edges inside the Node from the schema definition\n  const edgeType = stripNonNullType(gqlType._fields.edges.type)\n  const strippedType = stripNonNullType(\n    stripNonNullType(edgeType.ofType)._fields.node.type\n  )\n  // let's remember those arguments on the connection\n  const args = queryASTNode.arguments\n  // and then find the fields being selected on the underlying type, also buried within edges and Node\n  const edges = spreadFragments(\n    queryASTNode.selectionSet.selections,\n    fragments,\n    gqlType.name\n  ).find(selection => selection.name.value === 'edges')\n  if (edges) {\n    queryASTNode =\n      spreadFragments(\n        edges.selectionSet.selections,\n        fragments,\n        gqlType.name\n      ).find(selection => selection.name.value === 'node') || {}\n  } else {\n    queryASTNode = {}\n  }\n  // place the arguments on this inner field, so our SQL AST picks it up later\n  queryASTNode.arguments = args\n  return { gqlType: strippedType, queryASTNode }\n}\n\nfunction stripNonNullType(type) {\n  return type.constructor.name === 'GraphQLNonNull' ? type.ofType : type\n}\n\n// go through and make sure se only ask for each sqlDep once per table\nexport function pruneDuplicateSqlDeps(sqlAST, namespace) {\n  const childrenToLoopOver = []\n  if (sqlAST.children) {\n    childrenToLoopOver.push(sqlAST.children)\n  }\n  if (sqlAST.typedChildren) {\n    childrenToLoopOver.push(...Object.values(sqlAST.typedChildren))\n  }\n\n  for (let children of childrenToLoopOver) {\n    // keep track of all the dependent columns at this depth in a Set\n    // use one Set per table. usually the table is the same. but sometimes they are pulling in data from\n    // a junction table.\n    const depsByTable = {}\n\n    // loop thru each child which has \"columnDeps\", remove it from the tree, and add it to the set\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i]\n      if (child.type === 'columnDeps') {\n        const keyName = child.fromOtherTable || ''\n        child.names.forEach(name => {\n          if (!depsByTable[keyName]) {\n            depsByTable[keyName] = new Set()\n          }\n          depsByTable[keyName].add(name)\n        })\n        children.splice(i, 1)\n        // or if its another table, recurse on it\n      } else if (child.type === 'table' || child.type === 'union') {\n        pruneDuplicateSqlDeps(child, namespace)\n      }\n    }\n\n    // now that we collected the \"columnDeps\", add them all to one node\n    // the \"names\" property will put all the column names in an object as keys\n    // the values of this object will be the SQL alias\n    for (let table in depsByTable) {\n      const newNode = new SQLASTNode(sqlAST, {\n        type: 'columnDeps',\n        names: {},\n        fromOtherTable: table || null\n      })\n      depsByTable[table].forEach(name => {\n        newNode.names[name] = namespace.generate('column', name)\n      })\n      children.push(newNode)\n    }\n  }\n}\n\nfunction getSortColumns(field, sqlASTNode, context) {\n  if (field.sortKey) {\n    sqlASTNode.sortKey = unthunk(field.sortKey, sqlASTNode.args || {}, context)\n  }\n  if (field.orderBy) {\n    sqlASTNode.orderBy = handleOrderBy(\n      unthunk(field.orderBy, sqlASTNode.args || {}, context)\n    )\n  }\n  if (field.junction) {\n    if (field.junction.sortKey) {\n      sqlASTNode.junction.sortKey = unthunk(\n        field.junction.sortKey,\n        sqlASTNode.args || {},\n        context\n      )\n    }\n    if (field.junction.orderBy) {\n      sqlASTNode.junction.orderBy = handleOrderBy(\n        unthunk(field.junction.orderBy, sqlASTNode.args || {}, context)\n      )\n    }\n  }\n  if (!sqlASTNode.sortKey && !sqlASTNode.orderBy) {\n    if (sqlASTNode.junction) {\n      if (!sqlASTNode.junction.sortKey && !sqlASTNode.junction.orderBy) {\n        throw new Error(\n          '\"sortKey\" or \"orderBy\" required if \"sqlPaginate\" is true'\n        )\n      }\n    } else {\n      throw new Error(\n        '\"sortKey\" or \"orderBy\" required if \"sqlPaginate\" is true'\n      )\n    }\n  }\n  if (sqlASTNode.sortKey && idx(sqlASTNode, _ => _.junction.sortKey)) {\n    throw new Error('\"sortKey\" must be on junction or main table, not both')\n  }\n  if (sqlASTNode.orderBy && idx(sqlASTNode, _ => _.junction.orderBy)) {\n    throw new Error('\"orderBy\" must be on junction or main table, not both')\n  }\n}\n\n// instead of fields, selections can be fragments, which is another group of selections\n// fragments can be arbitrarily nested\n// this function recurses through and gets the relevant fields\nfunction spreadFragments(selections, fragments, typeName) {\n  return flatMap(selections, selection => {\n    switch (selection.kind) {\n      case 'FragmentSpread':\n        const fragmentName = selection.name.value\n        const fragment = fragments[fragmentName]\n        return spreadFragments(\n          fragment.selectionSet.selections,\n          fragments,\n          typeName\n        )\n      case 'InlineFragment':\n        if (selection.typeCondition.name.value === typeName) {\n          return spreadFragments(\n            selection.selectionSet.selections,\n            fragments,\n            typeName\n          )\n        }\n        return []\n\n      default:\n        return selection\n    }\n  })\n}\n\nexport function handleOrderBy(orderBy) {\n  if (!orderBy) return undefined\n  const orderColumns = {}\n  if (typeof orderBy === 'object') {\n    for (let column in orderBy) {\n      let direction = orderBy[column].toUpperCase()\n      if (direction !== 'ASC' && direction !== 'DESC') {\n        throw new Error(direction + ' is not a valid sorting direction')\n      }\n      orderColumns[column] = direction\n    }\n  } else if (typeof orderBy === 'string') {\n    orderColumns[orderBy] = 'ASC'\n  } else {\n    throw new Error('\"orderBy\" is invalid type: ' + inspect(orderBy))\n  }\n  return orderColumns\n}\n"],"file":"index.js"}