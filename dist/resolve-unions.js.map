{"version":3,"sources":["../src/resolve-unions.js"],"names":["resolveUnions","data","sqlAST","Array","isArray","length","type","typeName","typedChildren","suffix","children","child","fieldName","qualifiedName","obj","qualifiedValue","nextLevelData","filter","flatMap","value","sqlBatch"],"mappings":"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","sourcesContent":["import { chain } from 'lodash'\nimport { isEmptyArray } from './util'\n\n// union types have additional processing. the field names have a @ and the typename appended to them.\n// need to strip those off and take whichever of those values are non-null\nexport default function resolveUnions(data, sqlAST) {\n  if (!data || (Array.isArray(data) && data.length === 0)) {\n    return\n  }\n\n  if (sqlAST.type === 'union') {\n    for (let typeName in sqlAST.typedChildren) {\n      const suffix = '@' + typeName\n      const children = sqlAST.typedChildren[typeName]\n      for (let child of children) {\n        const fieldName = child.fieldName\n        const qualifiedName = child.fieldName + suffix\n        if (Array.isArray(data)) {\n          for (let obj of data) {\n            const qualifiedValue = obj[qualifiedName]\n            delete obj[qualifiedName]\n            if (obj[fieldName] == null && qualifiedValue != null) {\n              obj[fieldName] = qualifiedValue\n            } else if (\n              isEmptyArray(obj[fieldName]) &&\n              !isEmptyArray(qualifiedValue)\n            ) {\n              obj[fieldName] = qualifiedValue\n            }\n          }\n          if (child.type === 'table' || child.type === 'union') {\n            const nextLevelData = chain(data)\n              .filter(obj => obj != null)\n              .flatMap(obj => obj[fieldName])\n              .filter(obj => obj != null)\n              .value()\n            resolveUnions(nextLevelData, child)\n          }\n        } else {\n          const qualifiedValue = data[qualifiedName]\n          delete data[qualifiedName]\n          if (data[fieldName] == null && qualifiedValue != null) {\n            data[fieldName] = qualifiedValue\n          } else if (\n            isEmptyArray(data[fieldName]) &&\n            !isEmptyArray(qualifiedValue)\n          ) {\n            data[fieldName] = qualifiedValue\n          }\n          if (child.type === 'table' || child.type === 'union') {\n            resolveUnions(data[fieldName], child)\n          }\n        }\n      }\n    }\n  }\n  if (sqlAST.type === 'table' || sqlAST.type === 'union') {\n    for (let child of sqlAST.children) {\n      if (\n        (child.type === 'table' || child.type === 'union') &&\n        !child.sqlBatch\n      ) {\n        const fieldName = child.fieldName\n        if (Array.isArray(data)) {\n          const nextLevelData = chain(data)\n            .filter(obj => obj != null)\n            .flatMap(obj => obj[fieldName])\n            .filter(obj => obj != null)\n            .value()\n          resolveUnions(nextLevelData, child)\n        } else {\n          resolveUnions(data[fieldName], child)\n        }\n      }\n    }\n  }\n}\n"],"file":"resolve-unions.js"}