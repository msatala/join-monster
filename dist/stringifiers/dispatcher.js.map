{"version":3,"sources":["../../src/stringifiers/dispatcher.js"],"names":["stringifySqlAST","topNode","context","options","dialect","dialectModule","require","selections","tables","wheres","orders","_stringifySqlAST","batchScope","Set","length","sql","join","stringifyOuterOrder","quote","parent","node","prefix","q","parentTable","fromOtherTable","as","type","handleTable","child","children","typeName","typedChildren","push","name","names","compositeKey","expr","sqlExpr","args","Error","junction","where","orderBy","table","columns","sortKey","sortKeyToOrderColumns","sqlJoin","joinCondition","paginate","handleJoinedOneToManyPaginated","limit","first","sqlBatch","parentKey","handleBatchedManyToManyPaginated","sqlTable","thisKey","joinCondition1","sqlJoins","joinCondition2","handleJoinedManyToManyPaginated","handleBatchedOneToManyPaginated","handlePaginationAtRoot","fieldName","conditions","condition","column","direction","descending","order","toUpperCase","last","orderColumns","key"],"mappings":"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","sourcesContent":["import assert from 'assert'\nimport { filter } from 'lodash'\nimport idx from 'idx'\n\nimport { validateSqlAST, inspect, wrap } from '../util'\nimport {\n  joinPrefix,\n  thisIsNotTheEndOfThisBatch,\n  whereConditionIsntSupposedToGoInsideSubqueryOrOnNextBatch\n} from './shared'\n\nexport default async function stringifySqlAST(topNode, context, options) {\n  validateSqlAST(topNode)\n\n  let dialect = options.dialectModule\n\n  if (!dialect && options.dialect) {\n    dialect = require('./dialects/' + options.dialect)\n  }\n\n  // recursively figure out all the selections, joins, and where conditions that we need\n  let { selections, tables, wheres, orders } = await _stringifySqlAST(\n    null,\n    topNode,\n    [],\n    context,\n    [],\n    [],\n    [],\n    [],\n    options.batchScope,\n    dialect\n  )\n\n  // make sure these are unique by converting to a set and then back to an array\n  // e.g. we want to get rid of things like `SELECT user.id as id, user.id as id, ...`\n  // GraphQL does not prevent queries with duplicate fields\n  selections = [...new Set(selections)]\n\n  // bail out if they made no selections\n  if (!selections.length) return ''\n\n  // put together the SQL query\n  let sql = 'SELECT\\n  ' + selections.join(',\\n  ') + '\\n' + tables.join('\\n')\n\n  wheres = filter(wheres)\n  if (wheres.length) {\n    sql += '\\nWHERE ' + wheres.join(' AND ')\n  }\n\n  if (orders.length) {\n    sql += '\\nORDER BY ' + stringifyOuterOrder(orders, dialect.quote)\n  }\n\n  return sql\n}\n\nasync function _stringifySqlAST(\n  parent,\n  node,\n  prefix,\n  context,\n  selections,\n  tables,\n  wheres,\n  orders,\n  batchScope,\n  dialect\n) {\n  const { quote: q } = dialect\n  const parentTable = node.fromOtherTable || (parent && parent.as)\n  switch (node.type) {\n    case 'table':\n      await handleTable(\n        parent,\n        node,\n        prefix,\n        context,\n        selections,\n        tables,\n        wheres,\n        orders,\n        batchScope,\n        dialect\n      )\n\n      // recurse thru nodes\n      if (thisIsNotTheEndOfThisBatch(node, parent)) {\n        for (let child of node.children) {\n          await _stringifySqlAST(\n            node,\n            child,\n            [...prefix, node.as],\n            context,\n            selections,\n            tables,\n            wheres,\n            orders,\n            null,\n            dialect\n          )\n        }\n      }\n\n      break\n    case 'union':\n      await handleTable(\n        parent,\n        node,\n        prefix,\n        context,\n        selections,\n        tables,\n        wheres,\n        orders,\n        batchScope,\n        dialect\n      )\n\n      // recurse thru nodes\n      if (thisIsNotTheEndOfThisBatch(node, parent)) {\n        for (let typeName in node.typedChildren) {\n          for (let child of node.typedChildren[typeName]) {\n            await _stringifySqlAST(\n              node,\n              child,\n              [...prefix, node.as],\n              context,\n              selections,\n              tables,\n              wheres,\n              orders,\n              null,\n              dialect\n            )\n          }\n        }\n        for (let child of node.children) {\n          await _stringifySqlAST(\n            node,\n            child,\n            [...prefix, node.as],\n            context,\n            selections,\n            tables,\n            wheres,\n            orders,\n            null,\n            dialect\n          )\n        }\n      }\n\n      break\n    case 'column':\n      selections.push(\n        `${q(parentTable)}.${q(node.name)} AS ${q(\n          joinPrefix(prefix) + node.as\n        )}`\n      )\n      break\n    case 'columnDeps':\n      // grab the dependant columns\n      for (let name in node.names) {\n        selections.push(\n          `${q(parentTable)}.${q(name)} AS ${q(\n            joinPrefix(prefix) + node.names[name]\n          )}`\n        )\n      }\n      break\n    case 'composite':\n      selections.push(\n        `${dialect.compositeKey(parentTable, node.name)} AS ${q(\n          joinPrefix(prefix) + node.as\n        )}`\n      )\n      break\n    case 'expression':\n      const expr = await node.sqlExpr(\n        `${q(parentTable)}`,\n        node.args || {},\n        context,\n        node\n      )\n      selections.push(`${expr} AS ${q(joinPrefix(prefix) + node.as)}`)\n      break\n    case 'noop':\n      // we hit this with fields that don't need anything from SQL, they resolve independently\n      return\n    default:\n      throw new Error('unexpected/unknown node type reached: ' + inspect(node))\n  }\n  return { selections, tables, wheres, orders }\n}\n\nasync function handleTable(\n  parent,\n  node,\n  prefix,\n  context,\n  selections,\n  tables,\n  wheres,\n  orders,\n  batchScope,\n  dialect\n) {\n  const { quote: q } = dialect\n  // generate the \"where\" condition, if applicable\n  if (whereConditionIsntSupposedToGoInsideSubqueryOrOnNextBatch(node, parent)) {\n    if (idx(node, _ => _.junction.where)) {\n      wheres.push(\n        await node.junction.where(\n          `${q(node.junction.as)}`,\n          node.args || {},\n          context,\n          node\n        )\n      )\n    }\n    // if (node.where) {\n    //   wheres.push(\n    //     await node.where(`${q(node.as)}`, node.args || {}, context, node)\n    //   )\n    // }\n  }\n\n  if (thisIsNotTheEndOfThisBatch(node, parent)) {\n    if (idx(node, _ => _.junction.orderBy)) {\n      orders.push({\n        table: node.junction.as,\n        columns: node.junction.orderBy\n      })\n    }\n    if (node.orderBy) {\n      orders.push({\n        table: node.as,\n        columns: node.orderBy\n      })\n    }\n    if (idx(node, _ => _.junction.sortKey)) {\n      orders.push({\n        table: node.junction.as,\n        columns: sortKeyToOrderColumns(node.junction.sortKey, node.args)\n      })\n    }\n    if (node.sortKey) {\n      orders.push({\n        table: node.as,\n        columns: sortKeyToOrderColumns(node.sortKey, node.args)\n      })\n    }\n  }\n\n  // one-to-many using JOIN\n  if (node.sqlJoin) {\n    const joinCondition = await node.sqlJoin(\n      `${q(parent.as)}`,\n      q(node.as),\n      node.args || {},\n      context,\n      node\n    )\n\n    // do we need to paginate? if so this will be a lateral join\n    if (node.paginate) {\n      await dialect.handleJoinedOneToManyPaginated(\n        parent,\n        node,\n        context,\n        tables,\n        joinCondition\n      )\n\n      // limit has a highly similar approach to paginating\n    } else if (node.limit) {\n      node.args.first = node.limit\n      await dialect.handleJoinedOneToManyPaginated(\n        parent,\n        node,\n        context,\n        tables,\n        joinCondition\n      )\n      // otherwite, just a regular left join on the table\n    } else {\n      tables.push(`LEFT JOIN ${node.name} ${q(node.as)} ON ${joinCondition}`)\n    }\n\n    // many-to-many using batching\n  } else if (idx(node, _ => _.junction.sqlBatch)) {\n    if (parent) {\n      selections.push(\n        `${q(parent.as)}.${q(node.junction.sqlBatch.parentKey.name)} AS ${q(\n          joinPrefix(prefix) + node.junction.sqlBatch.parentKey.as\n        )}`\n      )\n    } else {\n      const joinCondition = await node.junction.sqlBatch.sqlJoin(\n        `${q(node.junction.as)}`,\n        q(node.as),\n        node.args || {},\n        context,\n        node\n      )\n      if (node.paginate) {\n        await dialect.handleBatchedManyToManyPaginated(\n          parent,\n          node,\n          context,\n          tables,\n          batchScope,\n          joinCondition\n        )\n      } else if (node.limit) {\n        node.args.first = node.limit\n        await dialect.handleBatchedManyToManyPaginated(\n          parent,\n          node,\n          context,\n          tables,\n          batchScope,\n          joinCondition\n        )\n      } else {\n        tables.push(\n          `FROM ${node.junction.sqlTable} ${q(node.junction.as)}`,\n          `LEFT JOIN ${node.name} ${q(node.as)} ON ${joinCondition}`\n        )\n        // ensures only the correct records are fetched using the value of the parent key\n        wheres.push(\n          `${q(node.junction.as)}.${q(\n            node.junction.sqlBatch.thisKey.name\n          )} IN (${batchScope.join(',')})`\n        )\n      }\n    }\n\n    // many-to-many using JOINs\n  } else if (idx(node, _ => _.junction.sqlTable)) {\n    const joinCondition1 = await node.junction.sqlJoins[0](\n      `${q(parent.as)}`,\n      q(node.junction.as),\n      node.args || {},\n      context,\n      node\n    )\n    const joinCondition2 = await node.junction.sqlJoins[1](\n      `${q(node.junction.as)}`,\n      q(node.as),\n      node.args || {},\n      context,\n      node\n    )\n\n    if (node.paginate) {\n      await dialect.handleJoinedManyToManyPaginated(\n        parent,\n        node,\n        context,\n        tables,\n        joinCondition1,\n        joinCondition2\n      )\n    } else if (node.limit) {\n      node.args.first = node.limit\n      await dialect.handleJoinedManyToManyPaginated(\n        parent,\n        node,\n        context,\n        tables,\n        joinCondition1,\n        joinCondition2\n      )\n    } else {\n      tables.push(\n        `LEFT JOIN ${node.junction.sqlTable} ${q(\n          node.junction.as\n        )} ON ${joinCondition1}`\n      )\n    }\n    tables.push(`LEFT JOIN ${node.name} ${q(node.as)} ON ${joinCondition2}`)\n\n    // one-to-many with batching\n  } else if (node.sqlBatch) {\n    if (parent) {\n      selections.push(\n        `${q(parent.as)}.${q(node.sqlBatch.parentKey.name)} AS ${q(\n          joinPrefix(prefix) + node.sqlBatch.parentKey.as\n        )}`\n      )\n    } else if (node.paginate) {\n      await dialect.handleBatchedOneToManyPaginated(\n        parent,\n        node,\n        context,\n        tables,\n        batchScope\n      )\n    } else if (node.limit) {\n      node.args.first = node.limit\n      await dialect.handleBatchedOneToManyPaginated(\n        parent,\n        node,\n        context,\n        tables,\n        batchScope\n      )\n      // otherwite, just a regular left join on the table\n    } else {\n      tables.push(`FROM ${node.name} ${q(node.as)}`)\n      wheres.push(\n        `${q(node.as)}.${q(node.sqlBatch.thisKey.name)} IN (${batchScope.join(\n          ','\n        )})`\n      )\n    }\n    // otherwise, we aren't joining, so we are at the \"root\", and this is the start of the FROM clause\n  } else if (node.paginate) {\n    await dialect.handlePaginationAtRoot(parent, node, context, tables)\n  } else if (node.limit) {\n    node.args.first = node.limit\n    await dialect.handlePaginationAtRoot(parent, node, context, tables)\n  } else {\n    assert(\n      !parent,\n      `Object type for \"${node.fieldName}\" table must have a \"sqlJoin\" or \"sqlBatch\"`\n    )\n    tables.push(`FROM ${node.name} ${q(node.as)}`)\n  }\n}\n\n// we need one ORDER BY clause on at the very end to make sure everything comes back in the correct order\n// ordering inner(sub) queries DOES NOT guarantee the order of those results in the outer query\nfunction stringifyOuterOrder(orders, q) {\n  const conditions = []\n  for (let condition of orders) {\n    for (let column in condition.columns) {\n      const direction = condition.columns[column]\n      conditions.push(`${q(condition.table)}.${q(column)} ${direction}`)\n    }\n  }\n  return conditions.join(', ')\n}\n\nfunction sortKeyToOrderColumns(sortKey, args) {\n  let descending = sortKey.order.toUpperCase() === 'DESC'\n  if (args && args.last) {\n    descending = !descending\n  }\n  const orderColumns = {}\n  for (let column of wrap(sortKey.key)) {\n    orderColumns[column] = descending ? 'DESC' : 'ASC'\n  }\n  return orderColumns\n}\n"],"file":"dispatcher.js"}