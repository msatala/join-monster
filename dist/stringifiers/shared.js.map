{"version":3,"sources":["../../src/stringifiers/shared.js"],"names":["joinPrefix","prefix","slice","map","name","join","generateCastExpressionFromValueType","key","val","castTypes","string","type","doubleQuote","str","thisIsNotTheEndOfThisBatch","node","parent","sqlBatch","junction","whereConditionIsntSupposedToGoInsideSubqueryOrOnNextBatch","paginate","keysetPagingSelect","table","whereCondition","order","limit","as","options","joinCondition","joinType","extraJoin","q","condition","orderColumnsToString","columns","offsetPagingSelect","pagingWhereConditions","offset","orderColumns","conditions","column","push","interpretForOffsetPaging","dialect","args","last","Error","orderBy","includes","first","parseInt","after","interpretForKeysetPaging","sortTable","sortKey","descending","toUpperCase","cursorObj","validateCursor","sortKeyToWhereCondition","before","expectedKeys","actualKeys","Object","keys","expectedKeySet","Set","actualKeySet","has","keyObj","quote","sortColumns","sortValues","operator","recursiveWhereJoin","values","op","pop","_recursiveWhereJoin","length","value"],"mappings":"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","sourcesContent":["import { filter } from 'lodash'\nimport { cursorToOffset } from 'graphql-relay'\nimport { wrap, cursorToObj, maybeQuote } from '../util'\nimport idx from 'idx'\n\nexport function joinPrefix(prefix) {\n  return prefix\n    .slice(1)\n    .map(name => name + '__')\n    .join('')\n}\n\nexport function generateCastExpressionFromValueType(key, val) {\n  const castTypes = {\n    string: 'TEXT'\n  }\n  const type = castTypes[typeof val] || null\n\n  if (type) {\n    return `CAST(${key} AS ${type})`\n  }\n  return key\n}\n\nfunction doubleQuote(str) {\n  return `\"${str}\"`\n}\n\nexport function thisIsNotTheEndOfThisBatch(node, parent) {\n  return (!node.sqlBatch && !idx(node, _ => _.junction.sqlBatch)) || !parent\n}\n\nexport function whereConditionIsntSupposedToGoInsideSubqueryOrOnNextBatch(\n  node,\n  parent\n) {\n  return (\n    !node.paginate &&\n    (!(node.sqlBatch || idx(node, _ => _.junction.sqlBatch)) || !parent)\n  )\n}\n\nexport function keysetPagingSelect(\n  table,\n  whereCondition,\n  order,\n  limit,\n  as,\n  options = {}\n) {\n  let { joinCondition, joinType, extraJoin, q } = options\n  q = q || doubleQuote\n  whereCondition = filter(whereCondition).join(' AND ') || 'TRUE'\n  if (joinCondition) {\n    return `\\\n${joinType || ''} JOIN LATERAL (\n  SELECT ${q(as)}.*\n  FROM ${table} ${q(as)}\n  ${\n    extraJoin\n      ? `LEFT JOIN ${extraJoin.name} ${q(extraJoin.as)}\n    ON ${extraJoin.condition}`\n      : ''\n  }\n  WHERE ${whereCondition}\n  ORDER BY ${orderColumnsToString(order.columns, q, order.table)}\n  LIMIT ${limit}\n) ${q(as)} ON ${joinCondition}`\n  }\n  return `\\\nFROM (\n  SELECT ${q(as)}.*\n  FROM ${table} ${q(as)}\n  WHERE ${whereCondition}\n  ORDER BY ${orderColumnsToString(order.columns, q, order.table)}\n  LIMIT ${limit}\n) ${q(as)}`\n}\n\nexport function offsetPagingSelect(\n  table,\n  pagingWhereConditions,\n  order,\n  limit,\n  offset,\n  as,\n  options = {}\n) {\n  let { joinCondition, joinType, extraJoin, q } = options\n  q = q || doubleQuote\n  const whereCondition = filter(pagingWhereConditions).join(' AND ') || 'TRUE'\n  if (joinCondition) {\n    return `\\\n${joinType || ''} JOIN LATERAL (\n  SELECT ${q(as)}.*\n  FROM ${table} ${q(as)}\n  ${\n    extraJoin\n      ? `LEFT JOIN ${extraJoin.name} ${q(extraJoin.as)}\n    ON ${extraJoin.condition}`\n      : ''\n  }\n  WHERE ${whereCondition}\n  ORDER BY ${orderColumnsToString(order.columns, q, order.table)}\n  LIMIT ${limit} OFFSET ${offset}\n) ${q(as)} ON ${joinCondition}`\n  }\n  return `\\\nFROM (\n  SELECT ${q(as)}.*\n  FROM ${table} ${q(as)}\n  WHERE ${whereCondition}\n  ORDER BY ${orderColumnsToString(order.columns, q, order.table)}\n  LIMIT ${limit} OFFSET ${offset}\n) ${q(as)}`\n}\n\nexport function orderColumnsToString(orderColumns, q, as) {\n  const conditions = []\n  for (let column in orderColumns) {\n    conditions.push(\n      `${as ? q(as) + '.' : ''}${q(column)} ${orderColumns[column]}`\n    )\n  }\n  return conditions.join(', ')\n}\n\n// find out what the limit, offset, order by parts should be from the relay connection args if we're paginating\nexport function interpretForOffsetPaging(node, dialect) {\n  const { name } = dialect\n  if (idx(node, _ => _.args.last)) {\n    throw new Error(\n      'Backward pagination not supported with offsets. Consider using keyset pagination instead'\n    )\n  }\n\n  const order = {}\n  if (node.orderBy) {\n    order.table = node.as\n    order.columns = node.orderBy\n  } else {\n    order.table = node.junction.as\n    order.columns = node.junction.orderBy\n  }\n\n  let limit = ['mariadb', 'mysql', 'oracle'].includes(name)\n    ? '18446744073709551615'\n    : 'ALL'\n  let offset = 0\n  if (idx(node, _ => _.args.first)) {\n    limit = parseInt(node.args.first, 10)\n    // we'll get one extra item (hence the +1). this is to determine if there is a next page or not\n    if (node.paginate) {\n      limit++\n    }\n    if (node.args.after) {\n      offset = cursorToOffset(node.args.after) + 1\n    }\n  }\n  return { limit, offset, order }\n}\n\nexport function interpretForKeysetPaging(node, dialect) {\n  const { name } = dialect\n\n  let sortTable\n  let sortKey\n  let descending\n  const order = { columns: {} }\n  if (node.sortKey) {\n    sortKey = node.sortKey\n    descending = sortKey.order.toUpperCase() === 'DESC'\n    sortTable = node.as\n    // flip the sort order if doing backwards paging\n    if (idx(node, _ => _.args.last)) {\n      descending = !descending\n    }\n    for (let column of wrap(sortKey.key)) {\n      order.columns[column] = descending ? 'DESC' : 'ASC'\n    }\n    order.table = node.as\n  } else {\n    sortKey = node.junction.sortKey\n    descending = sortKey.order.toUpperCase() === 'DESC'\n    sortTable = node.junction.as\n    // flip the sort order if doing backwards paging\n    if (idx(node, _ => _.args.last)) {\n      descending = !descending\n    }\n    for (let column of wrap(sortKey.key)) {\n      order.columns[column] = descending ? 'DESC' : 'ASC'\n    }\n    order.table = node.junction.as\n  }\n\n  let limit = ['mariadb', 'mysql', 'oracle'].includes(name)\n    ? '18446744073709551615'\n    : 'ALL'\n  let whereCondition = ''\n  if (idx(node, _ => _.args.first)) {\n    limit = parseInt(node.args.first, 10) + 1\n    if (node.args.after) {\n      const cursorObj = cursorToObj(node.args.after)\n      validateCursor(cursorObj, wrap(sortKey.key))\n      whereCondition = sortKeyToWhereCondition(\n        cursorObj,\n        descending,\n        sortTable,\n        dialect\n      )\n    }\n    if (node.args.before) {\n      throw new Error('Using \"before\" with \"first\" is nonsensical.')\n    }\n  } else if (idx(node, _ => _.args.last)) {\n    limit = parseInt(node.args.last, 10) + 1\n    if (node.args.before) {\n      const cursorObj = cursorToObj(node.args.before)\n      validateCursor(cursorObj, wrap(sortKey.key))\n      whereCondition = sortKeyToWhereCondition(\n        cursorObj,\n        descending,\n        sortTable,\n        dialect\n      )\n    }\n    if (node.args.after) {\n      throw new Error('Using \"after\" with \"last\" is nonsensical.')\n    }\n  }\n\n  return { limit, order, whereCondition }\n}\n\n// the cursor contains the sort keys. it needs to match the keys specified in the `sortKey` on this field in the schema\nexport function validateCursor(cursorObj, expectedKeys) {\n  const actualKeys = Object.keys(cursorObj)\n  const expectedKeySet = new Set(expectedKeys)\n  const actualKeySet = new Set(actualKeys)\n  for (let key of actualKeys) {\n    if (!expectedKeySet.has(key)) {\n      throw new Error(\n        `Invalid cursor. The column \"${key}\" is not in the sort key.`\n      )\n    }\n  }\n  for (let key of expectedKeys) {\n    if (!actualKeySet.has(key)) {\n      throw new Error(\n        `Invalid cursor. The column \"${key}\" is not in the cursor.`\n      )\n    }\n  }\n}\n\n// take the sort key and translate that for the where clause\nfunction sortKeyToWhereCondition(keyObj, descending, sortTable, dialect) {\n  const { name, quote: q } = dialect\n  const sortColumns = []\n  const sortValues = []\n  for (let key in keyObj) {\n    sortColumns.push(`${q(sortTable)}.${q(key)}`)\n    sortValues.push(maybeQuote(keyObj[key], name))\n  }\n  const operator = descending ? '<' : '>'\n  return name === 'oracle'\n    ? recursiveWhereJoin(sortColumns, sortValues, operator)\n    : `(${sortColumns.join(', ')}) ${operator} (${sortValues.join(', ')})`\n}\n\nfunction recursiveWhereJoin(columns, values, op) {\n  const condition = `${columns.pop()} ${op} ${values.pop()}`\n  return _recursiveWhereJoin(columns, values, op, condition)\n}\n\nfunction _recursiveWhereJoin(columns, values, op, condition) {\n  if (!columns.length) {\n    return condition\n  }\n  const column = columns.pop()\n  const value = values.pop()\n  condition = `(${column} ${op} ${value} OR (${column} = ${value} AND ${condition}))`\n  return _recursiveWhereJoin(columns, values, op, condition)\n}\n"],"file":"shared.js"}